O	0	3	How
O	4	6	do
O	7	8	I
O	9	13	left
O	14	17	pad
O	18	19	a
O	20	24	byte
O	25	30	array
O	31	42	efficiently

O	43	51	Assuming
O	52	53	I
O	54	58	have
O	59	61	an
O	62	67	array
O	68	87	@codeSnippetRemoved

O	88	89	I
O	90	95	would
O	96	100	like
O	101	103	to
O	104	110	create
O	111	113	an
O	114	119	array
O	120	122	of
O	123	125	an
O	126	135	arbitrary
O	136	142	length
O	143	146	and
O	147	151	left
O	152	155	pad
O	156	158	it
O	159	163	with
O	164	168	0x00
O	169	188	@codeSnippetRemoved

O	189	190	I
O	191	195	have
O	196	198	my
O	199	206	current
O	207	214	snippet
O	215	219	here
O	220	239	@codeSnippetRemoved

O	240	242	Is
O	243	248	there
O	249	250	a
O	251	255	more
O	256	265	efficient
O	266	269	way
O	270	272	to
O	273	275	do
O	276	280	this
O	280	281	?

O	282	283	I
O	284	289	would
O	290	299	recommend
O	300	308	starting
O	309	313	with
B-API	314	324	Array.Copy
O	325	329	like
O	330	334	this
O	335	336	:
O	337	356	@codeSnippetRemoved

O	357	359	If
O	360	363	you
O	364	370	really
O	371	375	need
O	376	379	the
O	380	385	speed
O	386	389	you
O	390	393	can
O	394	396	do
B-API	397	413	Buffer.BlockCopy
O	414	417	too
O	418	419	:
O	420	439	@codeSnippetRemoved

O	440	444	Note
O	445	449	that
O	450	451	I
O	452	455	did
O	456	459	not
O	460	465	check
O	466	469	the
O	470	476	length
O	477	479	of
O	480	483	the
O	484	489	array
O	490	493	you
O	494	502	provided
O	503	504	-
O	505	508	you
O	509	515	should
O	516	520	take
O	521	525	care
O	526	530	that
O	531	533	it
O	534	535	'
O	536	537	s
O	538	541	big
O	542	548	enough
O	548	549	.

O	550	555	There
O	556	559	are
O	560	564	some
O	565	570	other
O	571	580	overloads
O	581	583	of
B-API	584	592	GetBytes
O	593	597	that
O	598	601	you
O	602	605	can
O	606	609	use
O	609	610	.

O	611	614	One
O	615	617	of
O	618	622	them
O	623	629	allows
O	630	633	you
O	634	636	to
O	637	644	specify
O	645	646	a
O	647	655	starting
O	656	661	index
O	662	664	in
O	665	668	the
O	669	674	array
O	675	676	:
O	677	744	http://msdn.microsoft.com/en-us/library/595a8te7%28v=vs.110%29.aspx

O	745	748	You
O	749	752	can
O	753	756	use
O	757	760	the
B-API	761	773	GetByteCount
O	774	780	method
O	781	783	on
O	784	787	the
O	788	796	encoding
O	797	802	class
O	803	805	to
O	806	809	get
O	810	813	the
O	814	820	number
O	821	823	of
O	824	829	bytes
O	830	834	that
O	835	839	will
O	840	845	exist
O	846	851	after
O	852	855	the
O	856	864	encoding
O	864	865	,
O	866	874	although
O	875	881	adding
O	882	886	this
O	887	897	additional
O	898	902	call
O	903	906	may
O	907	913	negate
O	914	917	any
O	918	929	performance
O	930	937	benefit
O	937	938	.

O	939	942	You
O	943	946	may
O	947	951	know
O	952	956	that
O	957	960	the
O	961	965	byte
O	966	971	count
O	972	979	exactly
O	980	987	matches
O	988	991	the
O	992	998	string
O	999	1005	length
O	1006	1007	(
O	1007	1016	depending
O	1017	1021	upon
O	1022	1026	your
O	1027	1033	string
O	1034	1040	source
O	1040	1041	)
O	1041	1042	.

O	1043	1052	Depending
O	1053	1055	on
O	1056	1059	how
O	1060	1063	you
O	1064	1070	define
O	1071	1072	"
O	1072	1076	more
O	1077	1086	efficient
O	1086	1087	"
O	1088	1092	then
O	1093	1097	this
O	1098	1103	might
O	1104	1106	be
O	1107	1112	worth
O	1113	1118	doing
O	1119	1120	:
O	1121	1140	@codeSnippetRemoved

O	1141	1145	This
O	1146	1149	may
O	1150	1153	not
O	1154	1156	be
O	1157	1172	computationally
O	1173	1177	more
O	1178	1187	efficient
O	1187	1188	,
O	1189	1192	but
O	1193	1195	in
O	1196	1201	terms
O	1202	1204	of
O	1205	1211	making
O	1212	1215	the
O	1216	1220	code
O	1221	1226	clear
O	1227	1230	and
O	1231	1243	maintainable
O	1244	1247	you
O	1248	1253	might
O	1254	1262	consider
O	1263	1267	this
O	1268	1270	am
O	1271	1280	efficient
O	1281	1284	way
O	1285	1287	to
O	1288	1292	code
O	1292	1293	.
