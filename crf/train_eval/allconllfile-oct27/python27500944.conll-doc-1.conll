O	0	11	Appropriate
O	12	18	syntax
O	19	22	for
O	23	35	Initialising
B-PL	36	42	Python
O	43	48	C-API
O	49	58	container
O	59	64	types
O	65	66	(
O	66	70	List
O	71	75	Dict
O	76	81	Tuple
O	82	85	Set
O	85	86	)
O	87	89	in
B-PL	90	93	C++

O	94	97	I'm
O	98	107	designing
O	108	109	a
B-PL	110	113	C++
O	114	128	Python-wrapper
O	128	129	.

O	130	131	I
O	132	136	have
O	137	139	an
B-API	140	146	Object
O	147	152	class
O	153	155	to
O	156	160	wrap
O	161	162	a
O	163	170	generic
O	171	180	PyObject*
O	180	181	,
O	182	185	and
O	186	187	I
O	188	190	am
O	191	200	providing
O	201	213	constructors
O	214	217	and
O	218	228	conversion
O	229	238	operators
O	239	241	so
O	242	246	that
O	247	248	I
O	249	252	can
O	253	255	do
O	256	262	things
O	263	267	like
O	268	269	:
O	270	289	@codeSnippetRemoved

O	290	293	I'm
O	294	303	currently
O	304	311	looking
O	312	314	at
O	315	318	how
O	319	320	I
O	321	326	might
O	327	337	initialise
O	338	348	containers
O	349	350	:
B-API	351	362	PyDict_Type
I-API	363	374	PyList_Type
I-API	375	387	PyTuple_Type
I-API	388	398	PySet_Type
O	399	400	(
O	400	401	I
O	402	407	think
O	408	412	that
O	413	414	'
O	415	416	s
O	417	427	everything
O	427	428	?
O	428	429	)

O	430	432	It
O	433	440	appears
O	441	442	I
O	443	446	can
O	447	452	break
O	453	457	this
O	458	462	down
O	463	467	into
O	468	472	just
O	473	474	2
O	475	480	cases
O	481	482	:
B-API	483	494	PyList_Type
O	495	498	and
B-API	499	510	PyDict_Type
O	510	511	.

O	512	519	Because
O	520	523	for
O	524	525	{
B-API	526	537	PyList_Type
O	537	538	,
B-API	539	551	PyTuple_Type
O	551	552	,
B-API	553	563	PySet_Type
O	564	565	}
O	566	567	I
O	568	571	can
O	572	582	initialise
O	583	584	a
B-API	585	596	PyList_Type
O	597	600	and
O	601	613	subsequently
O	614	621	convert
O	622	624	it
O	624	625	.

O	626	628	My
O	629	637	question
O	638	640	is
O	641	642	:
O	643	647	What
B-PL	648	651	C++
O	652	658	syntax
O	659	665	should
O	666	667	I
O	668	675	provide
O	675	676	?

O	677	683	Seeing
O	684	686	as
O	687	689	it
O	690	692	is
O	693	695	my
O	696	700	goal
O	701	703	to
O	704	715	open-source
O	716	718	my
O	719	726	project
O	727	730	for
O	731	737	public
O	738	749	consumption
O	749	750	,
O	751	752	I
O	753	757	need
O	758	760	to
O	761	764	pay
O	765	774	attention
O	775	777	to
O	778	787	providing
O	788	789	a
O	790	796	usable
O	797	806	interface
O	807	811	that
O	812	817	isn't
O	818	823	going
O	824	826	to
B-Stan	827	830	jar
O	831	835	with
O	836	844	existing
O	845	851	design
O	852	860	patterns
O	860	861	.

O	862	872	Everything
O	873	877	that
O	878	885	follows
O	886	891	below
O	892	894	is
O	895	897	my
O	898	905	thought
O	906	913	process
O	913	914	,
O	915	918	and
O	919	921	my
O	922	925	own
O	926	933	attempt
O	934	936	to
O	937	943	answer
O	944	947	the
O	948	956	question
O	956	957	.

O	958	959	I
O	960	964	will
O	965	973	separate
O	974	976	it
O	976	977	.

O	978	982	Also
O	982	983	,
O	984	986	my
O	987	996	apologies
O	997	1001	that
O	1002	1006	this
O	1007	1010	may
O	1011	1013	be
O	1014	1016	an
O	1017	1021	open
O	1022	1030	question
O	1031	1032	(
O	1032	1036	more
O	1037	1041	than
O	1042	1045	one
O	1046	1054	solution
O	1054	1055	)
O	1055	1056	.

O	1057	1058	(
O	1058	1066	THOUGHTS
O	1067	1070	...
O	1070	1071	)

O	1072	1075	Let
O	1076	1077	'
O	1078	1079	s
O	1080	1083	say
O	1084	1085	I
O	1086	1090	want
O	1091	1093	to
O	1094	1104	initialise
O	1105	1106	a
O	1107	1111	list
O	1112	1113	:
O	1114	1133	@codeSnippetRemoved

O	1134	1137	std
O	1138	1140	::
B-API	1141	1157	initializer_list
O	1158	1164	Object
O	1165	1170	would
O	1171	1173	be
O	1174	1177	one
O	1178	1184	option
O	1184	1185	,
O	1186	1189	and
O	1190	1192	it
O	1193	1198	would
O	1199	1209	implicitly
O	1210	1218	typecast
O	1219	1224	every
O	1225	1233	argument
O	1234	1236	to
O	1237	1243	Object

O	1244	1247	But
O	1248	1251	now
O	1252	1256	what
O	1257	1262	would
O	1263	1266	one
O	1267	1271	want
O	1272	1280	Object{1
O	1281	1282	}
O	1283	1285	to
O	1286	1291	yield
O	1291	1292	?

O	1293	1301	Probably
O	1302	1303	a
B-API	1304	1314	PyInt_Type
O	1314	1315	.

O	1316	1319	But
O	1320	1323	the
B-API	1324	1340	initializer_list
O	1341	1352	constructor
O	1353	1355	is
O	1356	1361	going
O	1362	1364	to
O	1365	1375	overshadow
O	1376	1377	/
O	1378	1382	hide
O	1383	1385	it
O	1385	1386	.

O	1387	1390	And
O	1391	1395	then
O	1396	1408	dictionaries
O	1409	1410	:
O	1411	1430	@codeSnippetRemoved

O	1431	1436	Again
O	1436	1437	,
O	1438	1442	key2
O	1443	1448	might
O	1449	1452	not
O	1453	1455	be
O	1456	1459	the
O	1460	1464	same
O	1465	1469	type
O	1470	1472	as
O	1473	1477	key1
O	1477	1478	,
O	1479	1483	that
O	1484	1485	'
O	1486	1487	s
O	1488	1491	the
O	1492	1497	great
O	1498	1503	thing
O	1504	1509	about
B-PL	1510	1516	Python
O	1516	1517	.

O	1518	1520	In
B-PL	1521	1524	C++
O	1525	1526	I
O	1527	1532	don't
O	1533	1538	think
O	1539	1544	there
O	1545	1546	'
O	1547	1548	s
O	1549	1552	any
O	1553	1556	way
O	1557	1559	to
O	1560	1563	use
O	1564	1565	:
O	1565	1566	,
O	1567	1570	but
O	1571	1572	I
O	1573	1578	could
O	1579	1584	catch
O	1585	1586	{
O	1587	1588	{
O	1588	1589	,
O	1590	1591	}
O	1591	1592	,
O	1593	1594	{
O	1594	1595	,
O	1596	1597	}
O	1597	1598	,
O	1599	1600	{
O	1600	1601	,
O	1602	1603	}
O	1604	1605	}
O	1606	1610	with
O	1611	1614	std
O	1615	1617	::
O	1618	1621	map
O	1622	1628	Object
O	1628	1629	,
O	1630	1636	Object
O	1637	1639	or
O	1640	1643	std
O	1644	1646	::
O	1647	1651	pair

O	1652	1654	So
O	1655	1657	it
O	1658	1663	seems
O	1664	1666	to
O	1667	1669	be
O	1670	1673	the
O	1674	1678	List
O	1679	1683	that
O	1684	1686	is
O	1687	1690	the
O	1691	1698	biggest
O	1699	1706	problem
O	1706	1707	.

O	1708	1711	The
O	1712	1716	only
O	1717	1722	thing
O	1723	1724	I
O	1725	1728	can
O	1729	1734	think
O	1735	1737	of
O	1738	1742	this
O	1743	1749	having
O	1750	1751	a
O	1752	1757	first
O	1758	1766	argument
O	1767	1774	specify
O	1775	1779	type
O	1780	1781	:
O	1782	1801	@codeSnippetRemoved

O	1802	1806	This
O	1807	1812	would
O	1813	1817	have
O	1818	1822	some
O	1823	1832	advantage
O	1833	1836	for
O	1837	1843	typing
O	1844	1847	out
O	1848	1860	dictionaries
O	1860	1861	,
O	1862	1864	as
O	1865	1870	extra
O	1871	1877	braces
O	1878	1883	cause
O	1884	1891	clutter
O	1891	1892	,
O	1893	1901	although
O	1902	1903	I
O	1904	1910	should
O	1911	1915	also
O	1916	1921	allow
O	1922	1925	for
O	1926	1927	:
O	1928	1947	@codeSnippetRemoved

O	1948	1950	So
O	1951	1952	I
O	1953	1958	think
O	1959	1961	my
O	1962	1970	complete
O	1971	1974	set
O	1975	1977	of
O	1978	2005	constructors-for-containers
O	2006	2011	would
O	2012	2016	look
O	2017	2021	like
O	2022	2026	this
O	2027	2028	:
O	2029	2048	@codeSnippetRemoved

O	2049	2053	Then
O	2054	2057	for
O	2058	2066	symmetry
O	2067	2068	I
O	2069	2075	should
O	2076	2083	provide
O	2084	2085	:
O	2086	2105	@codeSnippetRemoved

O	2106	2109	...

O	2110	2118	Allowing
O	2119	2122	the
O	2123	2127	user
O	2128	2130	to
O	2131	2133	do
O	2134	2143	something
O	2144	2148	like
O	2149	2155	Object
O	2156	2170	f{PyFloat_Type
O	2170	2171	,
O	2172	2173	3
O	2174	2175	}
O	2176	2177	(
O	2177	2178	3
O	2179	2184	would
O	2185	2193	normally
O	2194	2197	get
O	2198	2207	converted
O	2208	2210	to
B-API	2211	2222	PyLong_Type
O	2222	2223	)

O	2224	2227	But
O	2228	2232	wait
O	2232	2233	!

O	2234	2235	3
O	2236	2238	is
O	2239	2242	not
O	2243	2248	going
O	2249	2251	to
O	2252	2254	be
O	2255	2265	implicitly
O	2266	2275	converted
O	2276	2278	to
O	2279	2285	Object
O	2285	2286	,
O	2287	2289	as
O	2290	2298	implicit
O	2299	2310	conversions
O	2311	2315	only
O	2316	2320	work
O	2321	2324	for
O	2325	2340	single-argument
O	2341	2353	constructors
O	2353	2354	.

O	2355	2374	@codeSnippetRemoved

O	2375	2380	Maybe
O	2381	2382	I
O	2383	2389	should
O	2390	2396	create
O	2397	2398	a
B-API	2399	2407	MakeLong
O	2408	2416	function
O	2416	2417	,
O	2418	2420	so
O	2421	2422	I
O	2423	2426	can
O	2427	2429	do
O	2430	2431	:
O	2432	2451	@codeSnippetRemoved

O	2452	2455	But
O	2456	2460	wait
O	2460	2461	,
O	2462	2467	can't
O	2468	2469	I
O	2470	2473	use
O	2474	2477	the
O	2478	2481	std
O	2482	2484	::
O	2485	2501	initializer_list
O	2502	2513	constructor
O	2514	2516	to
O	2517	2519	my
O	2520	2529	advantage
O	2530	2534	here
O	2534	2535	,
O	2536	2555	@codeSnippetRemoved

O	2556	2559	And
O	2560	2564	then
O	2565	2566	I
O	2567	2570	can
O	2571	2575	code
O	2576	2577	:
O	2578	2597	@codeSnippetRemoved

O	2598	2602	That
O	2603	2605	is
O	2606	2611	going
O	2612	2614	to
O	2615	2621	handle
O	2622	2632	everything
O	2632	2633	!

O	2634	2636	So
O	2637	2642	first
O	2643	2645	it
O	2646	2651	would
O	2652	2659	convert
O	2660	2661	{
O	2662	2663	3
O	2664	2665	}
O	2666	2670	into
O	2671	2672	a
O	2673	2677	list
O	2678	2688	containing
O	2689	2692	one
B-API	2693	2709	PyLong_Type.Then
O	2710	2712	it
O	2713	2717	will
O	2718	2722	pull
O	2723	2726	out
O	2727	2730	the
O	2731	2736	first
O	2737	2738	(
O	2738	2741	and
O	2742	2746	only
O	2746	2747	)
O	2748	2760	element.Then
O	2761	2763	it
O	2764	2768	will
O	2769	2776	convert
O	2777	2781	this
O	2782	2786	into
O	2787	2788	a
B-API	2789	2801	PyFloat_Type
O	2801	2802	.

O	2803	2806	The
O	2807	2812	first
O	2813	2821	solution
O	2822	2823	I
O	2824	2829	tried
O	2830	2833	was
O	2834	2836	to
O	2837	2840	use
O	2841	2844	std
O	2845	2847	::
B-API	2848	2864	initializer_list
O	2865	2867	as
O	2868	2875	follows
O	2876	2877	:
O	2878	2897	@codeSnippetRemoved

O	2898	2905	However
O	2905	2906	,
O	2907	2911	this
O	2912	2917	makes
O	2918	2921	for
O	2922	2926	some
O	2927	2936	seriously
O	2937	2941	ugly
O	2942	2948	syntax
O	2948	2949	,
O	2950	2952	as
O	2953	2955	it
O	2956	2961	fails
O	2962	2964	to
O	2965	2972	convert
O	2973	2982	arguments
O	2983	2985	to
O	2986	2993	Objects
O	2993	2994	,
O	2995	3004	appearing
O	3005	3007	to
O	3008	3015	require
O	3016	3017	:
O	3018	3037	@codeSnippetRemoved

O	3038	3040	So
O	3041	3042	I
O	3043	3050	settled
O	3051	3053	on
O	3054	3059	using
O	3060	3061	a
O	3062	3070	variadic
O	3071	3079	argument
O	3080	3081	:
O	3082	3101	@codeSnippetRemoved

O	3102	3106	This
O	3107	3116	technique
O	3117	3123	allows
O	3124	3127	for
O	3128	3129	a
O	3130	3134	tidy
O	3135	3146	lightweight
O	3147	3152	usage
O	3153	3159	syntax
O	3160	3161	:
O	3162	3181	@codeSnippetRemoved
