Appropriate	O
syntax	O
for	O
Initialising	O
Python	B-PL
C-API	O
container	O
types	O
(	O
List	O
Dict	O
Tuple	O
Set	O
)	O
in	O
C++	B-PL

I'm	O
designing	O
a	O
C++	B-PL
Python-wrapper	O
.	O

I	O
have	O
an	O
Object	O
class	O
to	O
wrap	O
a	O
generic	O
PyObject*	O
,	O
and	O
I	O
am	O
providing	O
constructors	O
and	O
conversion	O
operators	O
so	O
that	O
I	O
can	O
do	O
things	O
like	O
:	O
@codeSnippetRemoved	O

I'm	O
currently	O
looking	O
at	O
how	O
I	O
might	O
initialise	O
containers	O
:	O
PyDict_Type	O
PyList_Type	O
PyTuple_Type	O
PySet_Type	O
(	O
I	O
think	O
that	O
'	O
s	O
everything	O
?	O
)	O

It	O
appears	O
I	O
can	O
break	O
this	O
down	O
into	O
just	O
2	O
cases	O
:	O
PyList_Type	O
and	O
PyDict_Type	O
.	O

Because	O
for	O
{	O
PyList_Type	O
,	O
PyTuple_Type	O
,	O
PySet_Type	O
}	O
I	O
can	O
initialise	O
a	O
PyList_Type	O
and	O
subsequently	O
convert	O
it	O
.	O

My	O
question	O
is	O
:	O
What	O
C++	B-PL
syntax	O
should	O
I	O
provide	O
?	O

Seeing	O
as	O
it	O
is	O
my	O
goal	O
to	O
open-source	O
my	O
project	O
for	O
public	O
consumption	O
,	O
I	O
need	O
to	O
pay	O
attention	O
to	O
providing	O
a	O
usable	O
interface	O
that	O
isn't	O
going	O
to	O
jar	B-Stan
with	O
existing	O
design	O
patterns	O
.	O

Everything	O
that	O
follows	O
below	O
is	O
my	O
thought	O
process	O
,	O
and	O
my	O
own	O
attempt	O
to	O
answer	O
the	O
question	O
.	O

I	O
will	O
separate	O
it	O
.	O

Also	O
,	O
my	O
apologies	O
that	O
this	O
may	O
be	O
an	O
open	O
question	O
(	O
more	O
than	O
one	O
solution	O
)	O
.	O

(	O
THOUGHTS	O
...	O
)	O

Let	O
'	O
s	O
say	O
I	O
want	O
to	O
initialise	O
a	O
list	O
:	O
@codeSnippetRemoved	O

std	O
::	O
initializer_list	O
Object	O
would	O
be	O
one	O
option	O
,	O
and	O
it	O
would	O
implicitly	O
typecast	O
every	O
argument	O
to	O
Object	O

But	O
now	O
what	O
would	O
one	O
want	O
Object{1	O
}	O
to	O
yield	O
?	O

Probably	O
a	O
PyInt_Type	O
.	O

But	O
the	O
initializer_list	O
constructor	O
is	O
going	O
to	O
overshadow	O
/	O
hide	O
it	O
.	O

And	O
then	O
dictionaries	O
:	O
@codeSnippetRemoved	O

Again	O
,	O
key2	O
might	O
not	O
be	O
the	O
same	O
type	O
as	O
key1	O
,	O
that	O
'	O
s	O
the	O
great	O
thing	O
about	O
Python	B-PL
.	O

In	O
C++	B-PL
I	O
don't	O
think	O
there	O
'	O
s	O
any	O
way	O
to	O
use	O
:	O
,	O
but	O
I	O
could	O
catch	O
{	O
{	O
,	O
}	O
,	O
{	O
,	O
}	O
,	O
{	O
,	O
}	O
}	O
with	O
std	O
::	O
map	O
Object	O
,	O
Object	O
or	O
std	O
::	O
pair	O

So	O
it	O
seems	O
to	O
be	O
the	O
List	O
that	O
is	O
the	O
biggest	O
problem	O
.	O

The	O
only	O
thing	O
I	O
can	O
think	O
of	O
this	O
having	O
a	O
first	O
argument	O
specify	O
type	O
:	O
@codeSnippetRemoved	O

This	O
would	O
have	O
some	O
advantage	O
for	O
typing	O
out	O
dictionaries	O
,	O
as	O
extra	O
braces	O
cause	O
clutter	O
,	O
although	O
I	O
should	O
also	O
allow	O
for	O
:	O
@codeSnippetRemoved	O

So	O
I	O
think	O
my	O
complete	O
set	O
of	O
constructors-for-containers	O
would	O
look	O
like	O
this	O
:	O
@codeSnippetRemoved	O

Then	O
for	O
symmetry	O
I	O
should	O
provide	O
:	O
@codeSnippetRemoved	O

...	O

Allowing	O
the	O
user	O
to	O
do	O
something	O
like	O
Object	O
f{PyFloat_Type	O
,	O
3	O
}	O
(	O
3	O
would	O
normally	O
get	O
converted	O
to	O
PyLong_Type	O
)	O

But	O
wait	O
!	O

3	O
is	O
not	O
going	O
to	O
be	O
implicitly	O
converted	O
to	O
Object	O
,	O
as	O
implicit	O
conversions	O
only	O
work	O
for	O
single-argument	O
constructors	O
.	O

@codeSnippetRemoved	O

Maybe	O
I	O
should	O
create	O
a	O
MakeLong	B-API
function	O
,	O
so	O
I	O
can	O
do	O
:	O
@codeSnippetRemoved	O

But	O
wait	O
,	O
can't	O
I	O
use	O
the	O
std	O
::	O
initializer_list	O
constructor	O
to	O
my	O
advantage	O
here	O
,	O
@codeSnippetRemoved	O

And	O
then	O
I	O
can	O
code	O
:	O
@codeSnippetRemoved	O

That	O
is	O
going	O
to	O
handle	O
everything	O
!	O

So	O
first	O
it	O
would	O
convert	O
{	O
3	O
}	O
into	O
a	O
list	O
containing	O
one	O
PyLong_Type.Then	O
it	O
will	O
pull	O
out	O
the	O
first	O
(	O
and	O
only	O
)	O
element.Then	B-API
it	O
will	O
convert	O
this	O
into	O
a	O
PyFloat_Type	O
.	O

The	O
first	O
solution	O
I	O
tried	O
was	O
to	O
use	O
std	O
::	O
initializer_list	O
as	O
follows	O
:	O
@codeSnippetRemoved	O

However	O
,	O
this	O
makes	O
for	O
some	O
seriously	O
ugly	O
syntax	O
,	O
as	O
it	O
fails	O
to	O
convert	O
arguments	O
to	O
Objects	O
,	O
appearing	O
to	O
require	O
:	O
@codeSnippetRemoved	O

So	O
I	O
settled	O
on	O
using	O
a	O
variadic	O
argument	O
:	O
@codeSnippetRemoved	O

This	O
technique	O
allows	O
for	O
a	O
tidy	O
lightweight	O
usage	O
syntax	O
:	O
@codeSnippetRemoved	O
