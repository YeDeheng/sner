What	O
way	O
is	O
better	O
when	O
executing	O
queries	O
from	O
Java	B-PL

I	O
have	O
the	O
following	O
doubt	O
.	O

When	O
you	O
have	O
to	O
query	O
a	O
DB	O
from	O
a	O
Java	B-PL
application	O
there	O
are	O
several	O
ways	O
to	O
do	O
it	O
.	O

I	O
have	O
came	O
up	O
with	O
some	O
approaches	O
,	O
but	O
each	O
of	O
them	O
have	O
a	O
con	O
.	O

The	O
first	O
one	O
is	O
,	O
you	O
have	O
a	O
class	O
eg	O
.	O

QueryManager	B-API
which	O
provides	O
you	O
with	O
querying	O
functionalities	O
,	O
like	O
executeUpdate	O
(	O
...	O
)	O
and	O
executeQuery	O
(	O
...	O
)	O
while	O
hiding	O
details	O
of	O
the	O
management	O
of	O
connections	O
etc	O
.	O

(	O
Kind	O
of	O
a	O
Facade	O
Pattern	O
)	O
.	O

When	O
you	O
need	O
to	O
interact	O
with	O
the	O
DB	O
,	O
you	O
will	O
pass	O
the	O
query	O
as	O
a	O
String	O
and	O
manage	O
the	O
ResultSet	B-API
.	O

The	O
problem	O
that	O
I	O
see	O
is	O
that	O
if	O
the	O
DB	O
changes	O
,	O
whether	O
the	O
DBMS	O
or	O
the	O
DB	O
itself	O
,	O
you	O
will	O
end	O
up	O
going	O
file	O
by	O
file	O
modifying	O
the	O
SQL	B-PL
.	O

I	O
see	O
this	O
as	O
a	O
huge	O
dependency	O
.	O

Also	O
,	O
you	O
are	O
exposing	O
to	O
everyone	O
the	O
stucture	O
of	O
your	O
DB	O
and	O
you	O
are	O
making	O
each	O
class	O
to	O
handle	O
the	O
ResultSet	B-API
.	O

On	O
the	O
other	O
hand	O
,	O
you	O
could	O
achive	O
higher	O
modularity	O
by	O
using	O
this	O
method	O
,	O
since	O
the	O
models	O
(	O
I	O
am	O
a	O
fan	O
of	O
MVC	O
Pattern	O
)	O
of	O
your	O
classes	O
could	O
have	O
package	O
visibility	O
.	O

The	O
second	O
idea	O
that	O
came	O
to	O
my	O
mind	O
was	O
creating	O
a	O
QueryManager	B-API
class	O
that	O
instead	O
of	O
providing	O
you	O
with	O
the	O
methods	O
for	O
querying	O
,	O
it	O
will	O
provide	O
you	O
with	O
the	O
methods	O
you	O
need	O
.	O

In	O
other	O
words	O
,	O
each	O
time	O
you	O
need	O
to	O
use	O
the	O
DB	O
,	O
you	O
will	O
create	O
a	O
method	O
in	O
this	O
class	O
,	O
with	O
the	O
SQL	B-PL
inside	O
,	O
that	O
will	O
return	O
the	O
information	O
you	O
need	O
.	O

But	O
,	O
the	O
problem	O
we	O
are	O
facing	O
here	O
is	O
,	O
you	O
have	O
to	O
choose	O
between	O
returning	O
a	O
ResultSet	B-API
or	O
a	O
model	O
of	O
the	O
data	O
you	O
need	O
.	O

The	O
former	O
,	O
will	O
make	O
your	O
classes	O
dependant	O
on	O
the	O
DB	O
,	O
less	O
than	O
in	O
the	O
previous	O
example	O
,	O
since	O
now	O
there	O
is	O
no	O
widely	O
spread	O
dependency	O
with	O
the	O
DBMS	O
,	O
because	O
all	O
the	O
SQL	B-PL
is	O
contained	O
in	O
one	O
class	O
/	O
file	O
.	O

However	O
it	O
still	O
exists	O
a	O
dependency	O
with	O
the	O
DB	O
structure	O
and	O
you	O
are	O
exposing	O
,	O
as	O
well	O
,	O
your	O
DB	O
structure	O
to	O
everyone	O
.	O

The	O
later	O
implies	O
that	O
theese	O
models	O
no	O
longer	O
could	O
be	O
package	O
visibility	O
,	O
they	O
must	O
be	O
public	O
,	O
allowing	O
any	O
class	O
to	O
modify	O
them	O
,	O
and	O
breaking	O
encapsulation	O
.	O

Is	O
there	O
any	O
other	O
approach	O
that	O
solves	O
all	O
the	O
previous	O
problems	O
?	O

If	O
not	O
,	O
which	O
do	O
you	O
think	O
is	O
a	O
better	O
approach	O
?	O

I	O
do	O
not	O
think	O
there	O
is	O
an	O
absolute	O
answear	O
(	O
maybe	O
there	O
is	O
)	O
,	O
but	O
I	O
must	O
say	O
that	O
we	O
are	O
expecting	O
changes	O
in	O
both	O
the	O
structure	O
of	O
the	O
DB	O
and	O
in	O
the	O
DBMS	O
.	O

This	O
might	O
help	O
in	O
your	O
answear	O
.	O

But	O
try	O
to	O
make	O
it	O
as	O
general	O
as	O
possible	O
,	O
since	O
I	O
could	O
be	O
in	O
other	O
project	O
with	O
the	O
same	O
doubt	O
,	O
but	O
no	O
with	O
the	O
same	O
restrictions	O
.	O

I	O
suggest	O
to	O
create	O
DAO	O
classes	O
(	O
http://java.sun.com/blueprints/corej2eepatterns/Patterns/DataAccessObject.html	O
)	O
for	O
all	O
entities	O
,	O
that	O
will	O
hide	O
SQL	B-PL
/	O
HQL	O
/	O
whatever	O
inside	O
.	O

They	O
will	O
return	O
object	O
model	O
,	O
so	O
business-logic	O
classes	O
will	O
not	O
care	O
about	O
queries	O
/	O
fetching	O
from	O
database	O
/	O
etc	O
.	O

I	O
don't	O
like	O
either	O
of	O
your	O
approaches	O
.	O

You	O
can	O
write	O
a	O
single	O
interface	O
that	O
handles	O
all	O
of	O
it	O
:	O
the	O
generic	O
DAO	O
.	O

Here	O
'	O
s	O
a	O
simple	O
example	O
that	O
is	O
not	O
intended	O
to	O
be	O
the	O
complete	O
answer	O
,	O
because	O
it	O
does	O
not	O
allow	O
ad	O
hoc	O
queries	O
or	O
mapping	O
to	O
arbitrary	O
objects	O
,	O
but	O
it	O
'	O
s	O
a	O
start	O
:	O
@codeSnippetRemoved	O

You	O
should	O
have	O
a	O
clear	O
interface	O
between	O
persistence	O
and	O
model	O
classes	O
;	O
the	O
latter	O
need	O
not	O
know	O
about	O
the	O
former	O
.	O

You	O
should	O
not	O
allow	O
ResultSet	B-API
or	O
Statement	O
leak	O
out	O
of	O
the	O
persistence	O
layer	O
.	O

You	O
should	O
have	O
a	O
service	O
layer	O
that	O
obtains	O
connections	O
and	O
manages	O
transactions	O
.	O

You	O
should	O
write	O
SQL	B-PL
in	O
such	O
a	O
way	O
that	O
switching	O
databases	O
-	O
which	O
should	O
happen	O
rarely	O
if	O
at	O
all	O
-	O
is	O
as	O
simple	O
as	O
changing	O
the	O
JDBC	B-Stan
driver	O
JAR	B-Stan
and	O
connection	O
parameters	O
.	O

I	O
think	O
what	O
you're	O
after	O
is	O
the	O
data	O
access	O
object	O
(	O
DAO	O
)	O
pattern	O
.	O

If	O
you	O
use	O
a	O
framework	O
for	O
object-relational	O
mapping	O
like	O
Hibernate	B-Fram
,	O
your	O
DAOs	O
can	O
actually	O
specify	O
the	O
database	O
schema	O
directly	O
(	O
which	O
I	O
think	O
is	O
pretty	O
neat	O
)	O
.	O

Otherwise	O
,	O
it	O
'	O
s	O
typical	O
to	O
provide	O
a	O
set	O
of	O
hand-rolled	O
DAO	O
classes	O
which	O
abstract	O
away	O
all	O
the	O
underlying	O
database	O
concerns	O
(	O
e.g.	O
the	O
DAO	O
classes	O
should	O
not	O
return	O
ResultSet	B-API
)	O
.	O

The	O
second	O
one	O
is	O
the	O
good	O
one	O
:	O
you	O
should	O
extract	O
your	O
data	O
access	O
methods	O
in	O
Data	O
Access	O
Objects	O
(	O
DAOs	O
)	O
,	O
which	O
isolate	O
the	O
rest	B-Stan
of	O
the	O
application	O
from	O
persistence-related	O
problems	O
.	O

And	O
DAOs	O
should	O
definitely	O
return	O
objects	O
,	O
and	O
not	O
result	O
sets	O
.	O

This	O
provides	O
the	O
following	O
advantages	O
:	O

decoupling	O
of	O
concerns	O
and	O
responsibilities	O
easier	O
evolution	O
of	O
the	O
rest	B-Stan
of	O
the	O
application	O
when	O
the	O
schema	O
changes	O
easier	O
evolution	O
of	O
the	O
rest	B-Stan
of	O
the	O
application	O
when	O
you	O
choose	O
to	O
use	O
an	O
ORM	O
instead	O
of	O
JDBC	B-Stan
to	O
access	O
the	O
database	O
easier	O
unit-testing	O
of	O
the	O
queries	O
(	O
and	O
of	O
the	O
persistence	O
layer	O
in	O
general	O
)	O
,	O
since	O
the	O
persistence	O
code	O
is	O
not	O
mixed	O
with	O
functional	O
code	O
easier	O
unit-testing	O
of	O
the	O
business	O
(	O
service	O
)	O
layer	O
,	O
because	O
it	O
allows	O
injecting	O
mock	O
DAOs	O
to	O
provide	O
the	O
data	O
,	O
rather	O
than	O
needing	O
real	O
data	O
in	O
the	O
database	O
to	O
test	O
it	O
.	O

I	O
think	O
we	O
have	O
to	O
lookup	O
with	O
two	O
approaches	O
:	O
updatable	O
database	O
and	O
read-only	O
database	O
.	O

If	O
you	O
want	O
to	O
insert	O
/	O
update	O
/	O
delete	O
something	O
in	O
your	O
database	O
,	O
I	O
think	O
there	O
isn't	O
any	O
way	O
to	O
achieve	O
this	O
without	O
the	O
knowledge	O
about	O
how	O
is	O
your	O
database	O
:	O
names	O
,	O
data	O
types	O
...	O

But	O
,	O
at	O
the	O
other	O
hand	O
,	O
if	O
you	O
just	O
want	O
to	O
seach	O
in	O
your	O
database	O
,	O
there	O
'	O
s	O
a	O
good	O
way	O
to	O
achieve	O
this	O
:	O
using	O
database	O
views	O
.	O

You	O
can	O
have	O
a	O
lot	O
of	O
views	O
,	O
and	O
each	O
of	O
this	O
view	O
with	O
all	O
the	O
data	O
you	O
need	O
,	O
but	O
no	O
one	O
should	O
need	O
to	O
know	O
exactly	O
which	O
data	O
do	O
you	O
have	O
behind	O
the	O
views	O
.	O

You	O
can	O
restrict	O
some	O
users	O
to	O
only	O
see	O
the	O
views	O
,	O
and	O
not	O
the	O
original	O
tables	O
,	O
so	O
you	O
can	O
"	O
hide	O
"	O
your	O
real	O
database	O
structure	O
.	O

I	O
think	O
this	O
is	O
more	O
than	O
Java	B-PL
approach	O
:	O
it	O
'	O
s	O
a	O
Database	O
+	O
java	B-PL
Approach	O
.	O
