How	O
do	O
I	O
send	O
video	O
files	O
that	O
are	O
being	O
transcoded	O
live	O
with	O
Python	B-PL
'	O
s	O
Twisted.web	B-API
?	O

I'm	O
building	O
a	O
video	O
streamer	O
using	O
Python	B-PL
'	O
s	O
Twisted.web	B-API
with	O
callbacks	O
to	O
ffmpeg	O
.	O

I'm	O
wondering	O
,	O
since	O
I'm	O
sending	O
the	O
files	O
through	O
using	O
'	O
return	O
file.read()	B-API
'	O
there'll	O
be	O
problems	O
with	O
sending	O
the	O
transcoded	O
output	O
since	O
it	O
won't	O
be	O
available	O
to	O
be	O
read	O
in	O
entirety	O
?	O

Am	O
I	O
over	O
thinking	O
this	O
and	O
it	O
'	O
s	O
all	O
managed	O
by	O
Twisted.web	B-API
'	O
s	O
low	O
level	O
management	O
code	O
or	O
do	O
I	O
have	O
to	O
rethink	O
my	O
method	O
?	O

Additionally	O
,	O
how	O
can	O
I	O
support	O
people	O
skipping	O
ahead	O
to	O
parts	O
of	O
the	O
video	O
that	O
haven't	O
buffered	O
for	O
them	O
?	O

I	O
expect	O
it	O
to	O
be	O
a	O
really	O
complicated	O
,	O
but	O
just	O
incase	O
it	O
isn't	O
.	O

Thanks	O

1	O
)	O
Can	O
I	O
use	O
file.read()	B-API
in	O
twisted	O
?	O

The	O
short	O
answer	O
is	O
"	O
no	O
"	O
.	O

Unless	O
you've	O
done	O
a	O
bunch	O
of	O
other	O
relatively	O
complicated	O
things	O
,	O
such	O
as	O
set	O
O_NONBLOCK	O
on	O
the	O
fd	O
,	O
or	O
explicitly	O
delegated	O
this	O
request	O
to	O
separate	O
thread	O
,	O
file.read()	B-API
is	O
a	O
blocking	O
call	O
,	O
that	O
will	O
read	O
the	O
entirety	O
of	O
the	O
file	O
into	O
memory	O
before	O
it	O
returns	O
.	O

While	O
this	O
data	O
is	O
being	O
read	O
from	O
disk	O
synchronously	O
,	O
Twisted	O
'	O
s	O
reactor	O
will	O
be	O
unable	O
to	O
invoke	O
any	O
callbacks	O
or	O
read	O
or	O
write	O
any	O
available	O
data	O
on	O
any	O
fds	O
,	O
causing	O
any	O
other	O
pending	O
requests	O
or	O
streaming	O
transfers	O
to	O
grind	O
to	O
a	O
complete	O
halt	O
while	O
your	O
file	O
is	O
being	O
read	O
into	O
memory	O
.	O

Moreover	O
,	O
if	O
the	O
source	O
volume	O
of	O
the	O
file	O
is	O
under	O
heavy	O
load	O
and	O
/	O
or	O
there	O
are	O
lots	O
of	O
files	O
,	O
even	O
the	O
open()	B-API
calls	O
to	O
get	O
file	O
objects	O
may	O
block	O
for	O
a	O
significant	O
amount	O
of	O
time	O
.	O

There	O
is	O
no	O
nonblocking	O
open	O
,	O
so	O
if	O
you	O
need	O
a	O
file	O
object	O
,	O
you	O
should	O
use	O
reactor.deferToThread()	B-API
if	O
you	O
need	O
to	O
get	O
a	O
regular	O
file	O
object	O
in	O
twisted	O
.	O

So	O
here	O
'	O
s	O
what	O
you	O
should	O
do	O
:	O

For	O
reading	O
files	O
directly	O
from	O
the	O
filesystem	O
with	O
twisted	O
,	O
you	O
should	O
look	O
into	O
twisted.web.server.Site	B-API
and	O
twisted.web.static.File	B-API
.	O

There	O
'	O
s	O
an	O
interesting	O
tutorial	O
on	O
them	O
here	O
.	O

Not	O
only	O
will	O
these	O
calls	O
stream	O
the	O
file	O
content	O
from	O
disk	O
,	O
but	O
they	O
will	O
also	O
support	O
additional	O
HTTP	B-Stan
features	O
for	O
static	O
files	O
,	O
such	O
as	O
HTTP	B-Stan
Range	O
requests	O
.	O

2	O
)	O
How	O
can	O
I	O
support	O
people	O
skipping	O
ahead	O
to	O
parts	O
of	O
the	O
video	O
that	O
haven't	O
buffered	O
for	O
them	O
?	O

This	O
is	O
commonly	O
referred	O
to	O
as	O
scrubbing	O
,	O
and	O
there	O
are	O
basically	O
two	O
kinds	O
of	O
scrubbing	O
:	O
HTML5	B-PL
scrubbing	O
and	O
time-based	O
scrubbing	O
.	O

The	O
former	O
(	O
HTML5	B-PL
scrubbing	O
)	O
is	O
just	O
a	O
fancy	O
way	O
of	O
saying	O
"	O
HTTP	B-Stan
Range	O
requests	O
"	O
,	O
and	O
is	O
supported	O
by	O
native	O
browsers	O
and	O
plugins	O
,	O
such	O
as	O
Safari	O
Mobile	O
,	O
Quicktime	O
,	O
mplayer	O
,	O
and	O
all	O
browsers	O
that	O
implement	O
the	O
html5	B-PL
tag	O
.	O

This	O
is	O
supported	O
by	O
the	O
twisted.web.static.File	B-API
I	O
mentioned	O
in	O
my	O
answer	O
to	O
the	O
first	O
question	O
.	O

The	O
latter	O
(	O
time-based	O
scrubbing	O
)	O
is	O
the	O
legacy	O
way	O
of	O
supporting	O
scrubbing	O
.	O

It	O
is	O
basically	O
an	O
agreement	O
between	O
a	O
custom	O
player	O
(	O
such	O
as	O
jwplayer	O
or	O
OSMF	O
)	O
and	O
a	O
server	O
that	O
allows	O
the	O
player	O
to	O
request	O
the	O
video	O
starting	O
at	O
a	O
time	O
offset	O
specified	O
by	O
a	O
certain	O
query	O
parameter	O
.	O

This	O
can	O
be	O
done	O
hackily	O
by	O
starting	O
ffmpeg	O
in	O
a	O
subprocess	O
with	O
the	O
-itsoffset	O
parameter	O
pulled	O
from	O
the	O
required	O
query	O
parameter	O
,	O
using	O
some	O
input	O
file	O
from	O
disk	O
,	O
or	O
using	O
a	O
module	O
in	O
your	O
favorite	O
webserver	O
.	O

Either	O
way	O
requires	O
a	O
player	O
that	O
understands	O
what	O
query	O
parameter	O
to	O
send	O
.	O
