Accessing	O
property	O
of	O
an	O
object	O
whose	O
type	O
is	O
known	O
at	O
runtime	O

I	O
have	O
an	O
object	O
whose	O
base	O
type	O
is	O
exposed	O
to	O
be	O
at	O
compile	O
time	O
,	O
but	O
whose	O
runtime	O
type	O
is	O
internal	O
and	O
for	O
all	O
practical	O
purposes	O
I	O
am	O
unable	O
to	O
get	O
to	O
the	O
type	O
at	O
compile	O
time	O
.	O

However	O
,	O
I	O
want	O
to	O
be	O
able	O
to	O
access	O
a	O
property	O
on	O
its	O
instance	O
at	O
runtime	O
.	O

I	O
understand	O
that	O
without	O
knowing	O
the	O
type	O
at	O
compile	O
time	O
,	O
I	O
cannot	O
create	O
a	O
typed	O
delegate	O
.	O

What	O
is	O
the	O
most	O
performant	O
way	O
of	O
accessing	O
this	O
property	O
?	O

DynamicInvoke	B-API
?	O

Imagine	O
this	O
is	O
a	O
file	O
:	O
Hidden.cs	B-API
@codeSnippetRemoved	O

I	O
can't	O
type	O
the	O
following	O
in	O
my	O
code	O
Func	O
someExpression	O
=	O
Expression.Lambda	B-API
Func	O
Program	O
,	O
string	O
>	O
>	O
...	O

I	O
just	O
want	O
to	O
confirm	O
that	O
my	O
only	O
option	O
is	O
DynamicInvoke	B-API
when	O
I	O
can't	O
reference	O
the	O
type	O
at	O
compile	O
time	O
.	O

You	O
can	O
always	O
use	O
a	O
dynamic	O
delegate	O
,	O
such	O
as	O
a	O
Func	O
dynamic	O
,	O
T	O
,	O
with	O
T	O
being	O
your	O
return	O
type	O
.	O

But	O
remember	O
that	O
dynamic	O
dispatching	O
is	O
"	O
slow	O
"	O
,	O
as	O
it	O
uses	O
reflection	O
behind	O
the	O
sc	O
nes	O
.	O

DynamicInvoke	B-API
does	O
exactly	O
the	O
same	O
thing	O
,	O
so	O
it	O
'	O
s	O
just	O
as	O
slow	O
.	O

Now	O
remember	O
that	O
"	O
slow	O
"	O
is	O
very	O
relative	O
.	O

It	O
is	O
slow	O
compared	O
to	O
a	O
static	O
invocation	O
,	O
which	O
is	O
nearly	O
instant	O
,	O
but	O
this	O
kind	O
of	O
micro-optimization	O
is	O
hardly	O
ever	O
noticeable	O
in	O
a	O
real	O
program	O
.	O

Moreover	O
,	O
why	O
do	O
you	O
need	O
to	O
call	O
a	O
property	O
of	O
an	O
object	O
of	O
unknown	O
type	O
in	O
the	O
first	O
place	O
?	O

It	O
sounds	O
to	O
me	O
like	O
a	O
symptom	O
of	O
a	O
bad	O
design	O
decision	O
somewhere	O
down	O
the	O
road	O
.	O

Consider	O
for	O
instance	O
having	O
the	O
relevant	O
types	O
inherit	O
from	O
a	O
common	O
base	O
class	O
/	O
implement	O
the	O
same	O
interface	O
,	O
and	O
suddenly	O
your	O
problem	O
disappears	O
.	O

And	O
you	O
get	O
better	O
performances	O
as	O
a	O
bonus	O
.	O

edit	O

I	O
didn't	O
realize	O
at	O
first	O
that	O
you	O
wanted	O
to	O
access	O
a	O
member	O
you	O
should	O
not	O
be	O
able	O
to	O
see	O
.	O

Then	O
reflexion	O
is	O
your	O
only	O
hope	O
.	O

And	O
you	O
will	O
need	O
to	O
run	O
your	O
code	O
in	O
full	O
trust	O
too	O
.	O

Just	O
remember	O
that	O
the	O
original	O
creator	O
of	O
the	O
class	O
decided	O
not	O
to	O
give	O
you	O
access	O
to	O
this	O
member	O
and	O
he	O
could	O
have	O
very	O
good	O
reasons	O
for	O
that	O
.	O

You	O
shouldn't	O
do	O
that	O
unless	O
you	O
really	O
REALLY	O
can't	O
do	O
otherwise	O
.	O

You	O
can	O
create	O
Func	O
object	O
,	O
string	O
,	O
then	O
cast	O
the	O
object	O
to	O
Hidden	O
(	O
your	O
type	O
)	O
and	O
then	O
access	O
SomeProp	B-API
.	O

All	O
of	O
this	O
can	O
be	O
done	O
in	O
Expressions	O
like	O
this	O
:	O
@codeSnippetRemoved	O

Which	O
prints	O
"	O
Some	O
text	O
"	O
in	O
console	O
100	O
times	O
.	O
