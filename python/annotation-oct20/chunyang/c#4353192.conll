encrypting	O
password	O

i	O
am	O
about	O
to	O
make	O
a	O
'	O
log	O
in	O
'	O
for	O
my	O
app	O
and	O
was	O
wondering	O
what	O
is	O
the	O
best	O
way	O
to	O
encrypt	O
a	O
password	O
for	O
my	O
user	O
that	O
i	O
will	O
enter	O
in	O
my	O
database	O
?	O

I	O
found	O
many	O
way	O
on	O
Google	B-Orgs
but	O
don't	O
know	O
which	O
is	O
the	O
best	O
..	O

I	O
would	O
go	O
with	O
a	O
one	O
way	O
salted	O
hash	O
.	O

Using	O
a	O
SHA1	O
hash	O
for	O
example	O
,	O
you	O
would	O
have	O
a	O
way	O
to	O
store	O
the	O
password	O
as	O
a	O
hash	O
which	O
cannot	O
be	O
reversed	O
back	O
to	O
the	O
original	O
password	O
.	O

Then	O
when	O
the	O
user	O
enters	O
his	O
/	O
her	O
password	O
you	O
perform	O
the	O
same	O
SHA1	O
hash	O
on	O
the	O
password	O
and	O
compare	O
that	O
hash	O
with	O
what	O
you	O
have	O
stored	O
in	O
the	O
DB	O
,	O
if	O
they	O
match	O
then	O
the	O
password	O
is	O
correct	O
.	O

To	O
further	O
secure	O
the	O
hashing	O
,	O
you	O
can	O
add	O
a	O
salt	O
,	O
this	O
is	O
essentially	O
a	O
randomly	O
generated	O
value	O
that	O
you	O
generate	O
for	O
each	O
user	O
then	O
you	O
create	O
the	O
account	O
,	O
and	O
store	O
the	O
salt	O
value	O
in	O
the	O
user	O
record	O
.	O

When	O
you	O
create	O
the	O
hash	O
of	O
the	O
password	O
,	O
you	O
first	O
combine	O
the	O
password	O
with	O
the	O
salt	O
and	O
hash	O
this	O
combined	O
value	O
.	O

To	O
authenticate	O
the	O
user	O
you	O
combine	O
the	O
entered	O
password	O
with	O
the	O
salt	O
stored	O
for	O
the	O
user	O
,	O
perform	O
the	O
hash	O
on	O
the	O
combined	O
value	O
and	O
compare	O
.	O

By	O
adding	O
the	O
salt	O
to	O
the	O
mix	O
,	O
you	O
ensure	O
that	O
the	O
hash	O
for	O
passwords	O
that	O
happend	O
to	O
be	O
the	O
same	O
have	O
a	O
different	O
hash	O
because	O
the	O
salted	O
portion	O
differs	O
.	O

So	O
if	O
two	O
users	O
have	O
the	O
same	O
password	O
"	O
Password1234	O
"	O
,	O
the	O
stored	O
hash	O
for	O
the	O
two	O
will	O
not	O
be	O
the	O
same	O
so	O
it	O
cannot	O
be	O
determined	O
that	O
two	O
users	O
have	O
the	O
same	O
password	O
.	O

Use	O
Cryptography	O
algorithm	O
provided	O
by	O
.net	B-Fram
framework	O

normally	O
,	O
many	O
application	O
uses	O
MD5	O
algorithem	O

See	O
here	O

I	O
recommend	O
using	O
Rfc289	O
8D	O
eriveBytes	O

It	O
uses	O
a	O
good	O
standardized	O
Key-Derivation-Function	O
,	O
and	O
modern	O
hashes	O
.	O

You	O
need	O
to	O
pass	O
in	O
a	O
salt	O
in	O
addition	O
to	O
the	O
password	O
to	O
prevent	O
rainbow-tables	O
.	O

And	O
it	O
mixes	O
salt	O
and	O
password	O
for	O
you	O
,	O
so	O
you	O
don't	O
need	O
to	O
figure	O
out	O
how	O
to	O
do	O
that	O
yourself	O
.	O

Use	O
bcrypt	O
.	O

No	O
,	O
really	O
,	O
drop	O
whatever	O
ideas	O
you	O
have	O
of	O
building	O
your	O
own	O
method	O
,	O
and	O
use	O
bcrypt	O
.	O

The	O
world	O
has	O
enough	O
homebrew	O
insecure	O
password	O
hashing	O
schemes	O
already	O
.	O

Storing	O
salted	O
password	O
hashes	O
,	O
with	O
per-user	O
salts	O
of	O
course	O
,	O
is	O
all	O
well	O
and	O
good	O
.	O

But	O
salting	O
only	O
prevents	O
rainbow	O
table	O
attacks	O
,	O
it	O
doesn't	O
prevent	O
bruteforcing	O
.	O

So	O
,	O
paradoxically	O
,	O
you	O
don't	O
want	O
to	O
use	O
a	O
fast	O
method	O
to	O
generate	O
or	O
verify	O
the	O
password	O
hashes	O
.	O

MD5	O
,	O
SHA	O
,	O
whatever	O
-	O
they're	O
all	O
fast	O
.	O

Repeat	O
after	O
me	O
:	O
use	O
bcrypt	O
.	O

You	O
can	O
use	O
RSA	O
Algorithm	O
:	O
http://www.codeproject.com/KB/security/RSACryptoPad.aspx	O
