Batch	O
insert	O
using	O
JPA	B-Stan
/	O
Toplink	O

I	O
have	O
a	O
web	O
application	O
that	O
receives	O
messages	O
through	O
an	O
HTTP	B-Stan
interface	O
,	O
e.g.	O
:	O
@codeSnippetRemoved	O

This	O
request	O
contains	O
the	O
ID	O
of	O
the	O
sender	O
,	O
the	O
ID	O
of	O
the	O
recipient	O
and	O
the	O
text	O
of	O
the	O
message	O
.	O

This	O
message	O
should	O
be	O
processed	O
like	O
:	O

finding	O
the	O
matching	O
User	O
object	O
for	O
both	O
the	O
source	O
and	O
the	O
destination	O
from	O
the	O
database	O
creating	O
a	O
tree	O
of	O
objects	O
:	O
a	O
Message	O
that	O
contains	O
a	O
field	O
for	O
the	O
message	O
text	O
and	O
two	O
User	O
objects	O
for	O
the	O
source	O
and	O
the	O
destination	O
persisting	O
this	O
tree	O
to	O
a	O
database	O
.	O

The	O
tree	O
will	O
be	O
loaded	O
by	O
other	O
applications	O
that	O
I	O
can't	O
touch	O
.	O

I	O
use	O
Oracle	B-Orgs
as	O
the	O
backing	O
database	O
and	O
JPA	B-Stan
with	O
Toplink	O
for	O
the	O
database	O
handling	O
tasks	O
.	O

If	O
possible	O
,	O
I'd	O
stay	O
with	O
these	O
.	O

Without	O
much	O
optimization	O
I	O
can	O
achieve	O
~30	O
requests	O
/	O
sec	O
throughput	O
in	O
my	O
environment	O
.	O

That	O
'	O
s	O
not	O
much	O
,	O
I'd	O
require	O
~300	O
requests	O
/	O
sec	O
.	O

So	O
I	O
measured	O
where	O
the	O
performance	O
bottleneck	O
is	O
and	O
found	O
that	O
the	O
calls	O
to	O
em.persist()	B-API
takes	O
most	O
of	O
the	O
time	O
.	O

If	O
I	O
simply	O
comment	O
out	O
that	O
line	O
,	O
the	O
throughput	O
go	O
well	O
over	O
1000	O
requests	O
/	O
sec	O
.	O

I	O
tried	O
to	O
write	O
a	O
small	O
test	O
application	O
that	O
used	O
simple	O
JDBC	B-Stan
calls	O
to	O
persist	O
1	O
million	O
messages	O
to	O
the	O
same	O
database	O
.	O

I	O
used	O
batching	O
,	O
meaning	O
I	O
did	O
100	O
inserts	O
then	O
a	O
commit	O
,	O
and	O
repeated	O
until	O
all	O
the	O
records	O
was	O
in	O
the	O
database	O
.	O

I	O
measured	O
~500	O
requests	O
/	O
sec	O
throughput	O
in	O
this	O
scenario	O
,	O
that	O
would	O
meet	O
my	O
needs	O
.	O

It	O
is	O
clear	O
that	O
I	O
need	O
to	O
optimize	O
insert	O
performance	O
here	O
.	O

However	O
as	O
I	O
mentioned	O
earlier	O
I	O
would	O
like	O
to	O
keep	O
using	O
JPA	B-Stan
and	O
Toplink	O
for	O
this	O
,	O
not	O
pure	O
JDBC	B-Stan
.	O

Do	O
you	O
know	O
a	O
way	O
to	O
create	O
batch	O
inserts	O
with	O
JPA	B-Stan
and	O
Toplink	O
?	O

Can	O
you	O
recommend	O
any	O
other	O
technique	O
for	O
improving	O
JPA	B-Stan
persist	O
performance	O
?	O

ADDITIONAL	O
INFO	O
:	O

"	O
requests	O
/	O
sec	O
"	O
means	O
here	O
:	O
total	O
number	O
of	O
requests	O
/	O
total	O
time	O
from	O
beginning	O
of	O
test	O
to	O
last	O
record	O
written	O
to	O
database	O
.	O

I	O
tried	O
to	O
make	O
the	O
calls	O
to	O
em.persist()	B-API
asynchronous	O
by	O
creating	O
an	O
in-memory	O
queue	O
between	O
the	O
servlet	B-Stan
stuff	O
and	O
the	O
persister	O
.	O

It	O
helped	O
the	O
performance	O
greatly	O
.	O

However	O
the	O
queue	O
did	O
grow	O
really	O
fast	O
and	O
as	O
the	O
application	O
will	O
receive	O
~200	O
requests	O
/	O
second	O
continuously	O
,	O
It	O
is	O
not	O
an	O
acceptable	O
solution	O
for	O
me	O
.	O

In	O
this	O
decoupled	O
approach	O
I	O
collected	O
requests	O
for	O
100	O
msec	O
and	O
called	O
em.persist()	B-API
on	O
all	O
collected	O
items	O
before	O
commiting	O
the	O
transaction	O
.	O

The	O
EntityManagerFactory	B-API
is	O
cached	O
between	O
each	O
transaction	O
.	O

What	O
is	O
your	O
measure	O
of	O
"	O
requests	O
/	O
sec	O
"	O
?	O

In	O
other	O
words	O
,	O
what	O
happens	O
for	O
the	O
31st	O
request	O
?	O

What	O
resource	O
is	O
being	O
blocked	O
?	O

If	O
it	O
is	O
the	O
front-end	O
/	O
servlet	B-Stan
/	O
web	O
portion	O
,	O
can	O
you	O
run	O
em.persist()	B-API
in	O
another	O
thread	O
and	O
return	O
immediately	O
?	O

Also	O
,	O
are	O
you	O
creating	O
transactions	O
each	O
time	O
?	O

Are	O
you	O
creating	O
EntityManagerFactory	B-API
objects	O
with	O
each	O
request	O
?	O

You	O
should	O
decouple	O
from	O
the	O
JPA	B-Stan
interface	O
and	O
use	O
the	O
bare	O
TopLink	B-API
API	O
.	O

You	O
can	O
probably	O
chuck	O
the	O
objects	O
you're	O
persisting	O
into	O
a	O
UnitOfWork	B-API
and	O
commit	O
the	O
UnitOfWork	B-API
on	O
your	O
schedule	O
(	O
sync	O
or	O
async	O
)	O
.	O

Note	O
that	O
one	O
of	O
the	O
costs	O
of	O
em.persist()	B-API
is	O
the	O
implicit	O
clone	O
that	O
happens	O
of	O
the	O
whole	O
object	O
graph	O
.	O

TopLink	B-API
will	O
work	O
rather	O
better	O
if	O
you	O
uow.registerObject()	B-API
your	O
two	O
user	O
objects	O
yourself	O
,	O
saving	O
itself	O
the	O
identity	O
tests	O
it	O
has	O
to	O
otherwise	O
do	O
.	O

So	O
you'll	O
end	O
up	O
with	O
:	O
@codeSnippetRemoved	O

This	O
is	O
very	O
old	O
school	O
TopLink	B-API
btw	O
;)	O

Note	O
that	O
the	O
batch	O
will	O
help	O
a	O
lot	O
,	O
because	O
batch	O
writing	O
and	O
more	O
especially	O
batch	O
writing	O
with	O
parameter	O
binding	O
will	O
kick	O
in	O
which	O
for	O
this	O
simple	O
example	O
will	O
probably	O
have	O
a	O
very	O
large	O
impact	O
on	O
your	O
performance	O
.	O

Other	O
things	O
to	O
look	O
for	O
:	O
your	O
sequencing	O
size	O
.	O

A	O
lot	O
of	O
the	O
time	O
spent	O
writing	O
objects	O
in	O
TopLink	B-API
is	O
actually	O
spent	O
reading	O
sequencing	O
information	O
from	O
the	O
database	O
,	O
especially	O
with	O
the	O
small	O
defaults	O
(	O
I	O
would	O
probably	O
have	O
several	O
hundred	O
or	O
even	O
more	O
as	O
my	O
sequence	O
size	O
)	O
.	O
