Covering	O
index	O
decision	O
in	O
MySQL	O

My	O
MySQL	O
slow	O
query	O
log	O
showed	O
a	O
query	O
that	O
looks	O
rather	O
simple	O
as	O
one	O
of	O
the	O
slowest	O
queries	O
run	O
on	O
my	O
server	O
:	O
@codeSnippetRemoved	O

I'm	O
basically	O
trying	O
to	O
find	O
the	O
average	O
points	O
total	O
for	O
a	O
subgroup	O
(	O
set	O
of	O
uids	O
,	O
e.g.	O
based	O
on	O
gender	O
or	O
whatever	O
)	O
of	O
a	O
group	O
.	O

There	O
are	O
individual	O
indexes	O
on	O
uid	O
and	O
gid	O
,	O
but	O
EXPLAIN	O
shows	O
that	O
they're	O
not	O
being	O
used	O
:	O
@codeSnippetRemoved	O

Now	O
,	O
the	O
obvious	O
solution	O
,	O
as	O
I	O
understand	O
it	O
,	O
is	O
to	O
have	O
a	O
covering	O
index	O
over	O
these	O
fields	O
:	O
@codeSnippetRemoved	O

And	O
indeed	O
,	O
this	O
makes	O
it	O
use	O
the	O
index	O
:	O
@codeSnippetRemoved	O

However	O
,	O
I	O
have	O
two	O
questions	O
:	O

In	O
the	O
Extra	O
field	O
,	O
EXPLAIN	O
now	O
says	O
"	O
Using	O
where	O
;	O
Using	O
index	O
;	O
Using	O
temporary	O
;	O
Using	O
filesort	O
"	O
.	O

This	O
is	O
bad	O
,	O
right	O
?	O

So	O
should	O
I	O
use	O
this	O
index	O
or	O
not	O
?	O

In	O
dummy	O
terms	O
,	O
is	O
it	O
more	O
important	O
to	O
have	O
type=index	O
and	O
key=something	O
than	O
what	O
happens	O
in	O
the	O
"	O
extra	O
"	O
field	O
,	O
or	O
not	O
?	O

What	O
are	O
the	O
effects	O
of	O
having	O
a	O
covering	O
index	O
on	O
large	O
inserts	O
?	O

I	O
am	O
inserting	O
points	O
in	O
this	O
same	O
table	O
by	O
doing	O
a	O
JOIN	O
-	O
UPDATE	O
with	O
a	O
quite	O
large	O
temporary	O
table	O
.	O

I	O
wouldn't	O
want	O
to	O
slow	O
this	O
down	O
too	O
much	O
.	O

Using	O
Temporary	O
in	O
the	O
explain	O
output	O
means	O
that	O
a	O
temporary	O
table	O
was	O
created	O
to	O
satisfy	O
the	O
group	O
by	O
condition	O
.	O

This	O
is	O
not	O
very	O
bad	O
but	O
much	O
better	O
performance	O
can	O
be	O
achieved	O
if	O
you	O
optimise	O
group	O
by	O
for	O
"	O
Loose	O
Index	O
Scan	O
"	O
.	O

In	O
order	O
for	O
this	O
query	O
to	O
avoid	O
a	O
temporary	O
table	O
,	O
the	O
gid	O
column	O
has	O
to	O
be	O
indexed	O
so	O
it	O
is	O
the	O
left	O
most	O
part	O
of	O
a	O
composite	O
key	O
or	O
a	O
single	O
column	O
index	O
.	O

To	O
further	O
improve	O
it	O
,	O
uid	O
as	O
a	O
single	O
column	O
index	O
is	O
also	O
a	O
good	O
chice	O
:	O
@codeSnippetRemoved	O

Update	O
:	O

As	O
@Dow	O
correctly	O
pointed	O
out	O
,	O
the	O
use	O
of	O
AVG()	B-API
disqualifies	O
the	O
query	O
for	O
index	O
access	O
group	O
by	O
calculations	O
,	O
only	O
MIN()	B-API
and	O
MAX()	B-API
wouldn't	O
.	O

The	O
proposed	O
indexes	O
nevertheless	O
should	O
still	O
give	O
better	O
performance	O
.	O

In	O
general	O
,	O
you	O
can	O
use	O
an	O
index	O
to	O
optimize	O
the	O
range	O
predicate	O
of	O
IN	O
(	O
...	O
)	O
,	O
or	O
you	O
can	O
use	O
an	O
index	O
to	O
optimize	O
out	O
the	O
temp	O
table	O
caused	O
by	O
the	O
GROUP	O
BY	O
(	O
though	O
you	O
make	O
a	O
good	O
point	O
that	O
this	O
may	O
not	O
work	O
with	O
AVG()	B-API
)	O
.	O

But	O
you	O
can't	O
achieve	O
both	O
uses	O
of	O
indexes	O
in	O
the	O
same	O
SELECT	O
.	O

I'm	O
going	O
to	O
conclude	O
that	O
you	O
can't	O
get	O
rid	O
of	O
the	O
temp	O
table	O
in	O
this	O
particular	O
query	O
.	O

The	O
best	O
you	O
can	O
do	O
is	O
try	O
to	O
keep	O
it	O
from	O
going	O
to	O
disk	O
by	O
increasing	O
tmp_table_size	O
.	O

Or	O
if	O
it	O
does	O
go	O
to	O
disk	O
,	O
configure	O
a	O
tmpfs	O
filesystem	O
and	O
use	O
that	O
mount	O
point	O
as	O
your	O
tmpdir	O
.	O

So	O
you	O
have	O
to	O
choose	O
,	O
do	O
you	O
want	O
to	O
search	O
an	O
index	O
for	O
your	O
list	O
of	O
uid	O
values	O
?	O

You	O
have	O
a	O
really	O
long	O
list	O
of	O
uid's	O
,	O
so	O
that	O
'	O
s	O
going	O
to	O
be	O
costly	O
just	O
to	O
estimate	O
the	O
row	O
count	O
.	O

Be	O
sure	O
to	O
upgrade	O
to	O
MySQL	O
5.6	O
,	O
which	O
has	O
some	O
new	O
optimizations	O
in	O
this	O
area	O
(	O
see	O
Equality	O
Range	O
Optimization	O
of	O
Many-Valued	O
Comparisons	O
)	O
.	O

The	O
type=index	O
means	O
it	O
'	O
s	O
doing	O
an	O
index	O
scan	O
,	O
which	O
is	O
costly	O
but	O
at	O
least	O
it	O
'	O
s	O
getting	O
results	O
from	O
the	O
index	O
alone	O
instead	O
of	O
having	O
to	O
read	O
table	O
rows	O
.	O

So	O
it	O
needs	O
fewer	O
buffer	O
pool	O
pages	O
to	O
satisfy	O
this	O
query	O
.	O
