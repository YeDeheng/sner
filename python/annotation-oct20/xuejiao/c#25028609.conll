How	O
do	O
I	O
left	O
pad	O
a	O
byte	O
array	O
efficiently	O

Assuming	O
I	O
have	O
an	O
array	O
@codeSnippetRemoved	O

I	O
would	O
like	O
to	O
create	O
an	O
array	O
of	O
an	O
arbitrary	O
length	O
and	O
left	O
pad	O
it	O
with	O
0x00	O
@codeSnippetRemoved	O

I	O
have	O
my	O
current	O
snippet	O
here	O
@codeSnippetRemoved	O

Is	O
there	O
a	O
more	O
efficient	O
way	O
to	O
do	O
this	O
?	O

I	O
would	O
recommend	O
starting	O
with	O
Array.Copy	B-API
like	O
this	O
:	O
@codeSnippetRemoved	O

If	O
you	O
really	O
need	O
the	O
speed	O
you	O
can	O
do	O
Buffer.BlockCopy	B-API
too	O
:	O
@codeSnippetRemoved	O

Note	O
that	O
I	O
did	O
not	O
check	O
the	O
length	O
of	O
the	O
array	O
you	O
provided	O
-	O
you	O
should	O
take	O
care	O
that	O
it	O
'	O
s	O
big	O
enough	O
.	O

There	O
are	O
some	O
other	O
overloads	O
of	O
GetBytes	B-API
that	O
you	O
can	O
use	O
.	O

One	O
of	O
them	O
allows	O
you	O
to	O
specify	O
a	O
starting	O
index	O
in	O
the	O
array	O
:	O
http://msdn.microsoft.com/en-us/library/595a8te7%28v=vs.110%29.aspx	O

You	O
can	O
use	O
the	O
GetByteCount	B-API
method	O
on	O
the	O
encoding	O
class	O
to	O
get	O
the	O
number	O
of	O
bytes	O
that	O
will	O
exist	O
after	O
the	O
encoding	O
,	O
although	O
adding	O
this	O
additional	O
call	O
may	O
negate	O
any	O
performance	O
benefit	O
.	O

You	O
may	O
know	O
that	O
the	O
byte	O
count	O
exactly	O
matches	O
the	O
string	O
length	O
(	O
depending	O
upon	O
your	O
string	O
source	O
)	O
.	O

Depending	O
on	O
how	O
you	O
define	O
"	O
more	O
efficient	O
"	O
then	O
this	O
might	O
be	O
worth	O
doing	O
:	O
@codeSnippetRemoved	O

This	O
may	O
not	O
be	O
computationally	O
more	O
efficient	O
,	O
but	O
in	O
terms	O
of	O
making	O
the	O
code	O
clear	O
and	O
maintainable	O
you	O
might	O
consider	O
this	O
am	O
efficient	O
way	O
to	O
code	O
.	O
