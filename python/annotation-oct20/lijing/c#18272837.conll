Allow	O
templates	O
to	O
be	O
inferred	O

Say	O
I'm	O
using	O
an	O
external	O
package	O
for	O
storing	O
graphs	O
.	O

A	O
BidirectionalGraph	B-API
takes	O
two	O
templates	O
:	O
a	O
vertex	O
and	O
an	O
edge	O
type	O
:	O
@codeSnippetRemoved	O

Unfortunately	O
,	O
this	O
graph	O
package	O
doesn't	O
allow	O
you	O
to	O
get	O
the	O
edges	O
radiating	O
into	O
a	O
vertex	O
in	O
a	O
single	O
line	O
.	O

Instead	O
,	O
you	O
have	O
to	O
provide	O
an	O
IEnumerable	O
,	O
which	O
it	O
will	O
populate	O
with	O
the	O
results	O
.	O

This	O
can	O
disrupt	O
a	O
good	O
coding	O
rhythm	O
by	O
making	O
tasks	O
like	O
"	O
loop	O
through	O
all	O
vertices	O
that	O
are	O
successors	O
of	O
vertex	O
x	O
"	O
take	O
far	O
too	O
much	O
code	O
.	O

I	O
wanted	O
to	O
use	O
.NET	B-Fram
'	O
s	O
extensions	O
to	O
add	O
a	O
one-line	O
solution	O
to	O
the	O
graph	O
class	O
:	O
@codeSnippetRemoved	O

But	O
when	O
I	O
call	O
graph.IncomingEdges	B-API
(	O
vertex	O
)	O
,	O
for	O
some	O
reason	O
C#	B-PL
(	O
.NET	B-Fram
version	O
4.5	O
)	O
can't	O
infer	O
the	O
template	O
arguments	O
,	O
so	O
I	O
have	O
to	O
say	O
:	O

graph.IncomingEdges	B-API
GraphThatInheritsFromBidirectionalGraph	B-API
VertexType	B-API
,	O
EdgeType	B-API
,	O
VertexType	B-API
,	O
EdgeType	B-API
(	O
vertex	O
)	O
.	O

Not	O
really	O
a	O
great	O
improvement	O
.	O

First	O
,	O
why	O
can't	O
the	O
template	O
types	O
be	O
estimated	O
?	O

I	O
have	O
a	O
feeling	O
it	O
has	O
to	O
do	O
with	O
inheritance	O
,	O
but	O
don't	O
understand	O
.	O

I'm	O
used	O
to	O
using	O
C++	B-PL
,	O
and	O
for	O
some	O
reason	O
feel	O
that	O
gcc	O
could	O
infer	O
the	O
template	O
types	O
.	O

Second	O
,	O
if	O
this	O
can't	O
be	O
prevented	O
,	O
is	O
the	O
correct	O
design	O
choice	O
to	O
make	O
a	O
graph	O
class	O
for	O
actual	O
use	O
,	O
which	O
inherits	O
from	O
BidirectionalGraph	B-API
?	O

It	O
seems	O
a	O
waste	O
to	O
have	O
to	O
rewrite	O
the	O
constructors	O
,	O
but	O
I'm	O
sure	O
you'd	O
agree	O
that	O
calling	O
the	O
method	O
with	O
explicit	O
template	O
types	O
is	O
inelegant	O
.	O

EDIT	O
:	O

Strangely	O
,	O
the	O
equivalent	O
specification	O
(	O
below	O
)	O
does	O
allow	O
automatic	O
inference	O
of	O
template	O
types	O
.	O

So	O
,	O
even	O
though	O
it	O
solves	O
my	O
initial	O
problem	O
(	O
adding	O
this	O
functionality	O
to	O
the	O
graph	O
)	O
,	O
I'd	O
still	O
really	O
like	O
to	O
understand	O
.	O

@codeSnippetRemoved	O

The	O
first	O
version	O
of	O
your	O
extension	O
method	O
is	O
able	O
to	O
infer	O
TGraphType	O
and	O
TVertex	O
but	O
not	O
TEgde	O
,	O
as	O
it	O
would	O
require	O
inferring	O
the	O
TEdge	O
from	O
the	O
type	O
constraint	O
:	O
@codeSnippetRemoved	O

which	O
C#	B-PL
compiler	O
does	O
not	O
do	O
(	O
it	O
does	O
not	O
infer	O
generic	O
type	O
parameters	O
from	O
type	O
constraints	O
)	O
.	O

I	O
honestly	O
don't	O
know	O
if	O
there	O
is	O
a	O
technical	O
reason	O
behind	O
this	O
or	O
it	O
just	O
wasn't	O
implemented	O
.	O

Your	O
updated	O
version	O
,	O
on	O
the	O
other	O
hand	O
,	O
includes	O
BidirectionalGraph	B-API
TVertex	O
,	O
TEdge	O
as	O
a	O
parameter	O
,	O
so	O
for	O
example	O
when	O
you	O
call	O
the	O
extension	O
method	O
on	O
a	O
class	O
like	O
:	O
@codeSnippetRemoved	O

the	O
compiler	O
is	O
able	O
to	O
examine	O
the	O
type	O
AGraph	O
and	O
see	O
that	O
there	O
is	O
a	O
unique	O
type	O
BidirectionalGraph	B-API
AVertex	O
,	O
AnEdge	B-API
in	O
its	O
inheritance	O
hierarchy	O
,	O
so	O
it	O
is	O
able	O
to	O
infer	O
TVertex	O
and	O
TEdge	O
.	O

Note	O
that	O
if	O
the	O
parameter	O
type	O
were	O
IGraph	O
TVertex	O
,	O
TEdge	O
(	O
instead	O
of	O
BidirectionalGraph	B-API
TVertex	O
,	O
TEdge	O
)	O
and	O
AGraph	O
implemented	O
multiple	O
constructed	O
types	O
of	O
that	O
generic	O
interface	O
,	O
e.g.	O
:	O
@codeSnippetRemoved	O

then	O
type	O
inference	O
would	O
fail	O
once	O
again	O
because	O
it	O
can't	O
tell	O
if	O
,	O
for	O
example	O
,	O
TVertex	O
is	O
AVertex	O
or	O
AnotherVertex	B-API
.	O
