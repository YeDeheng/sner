Limiting	O
number	O
of	O
lines	O
in	O
textarea	O

I'm	O
looking	O
for	O
a	O
javascript	B-PL
that	O
can	O
limit	O
the	O
number	O
of	O
lines	O
(	O
by	O
line	O
I	O
mean	O
some	O
text	O
ended	O
by	O
user	O
pressing	O
enter	O
on	O
the	O
keyboard	O
)	O
the	O
user	O
is	O
able	O
to	O
enter	O
in	O
textarea	O
.	O

I've	O
found	O
some	O
solutions	O
but	O
they	O
simply	O
don't	O
work	O
or	O
behave	O
really	O
weird	O
.	O

The	O
best	O
solution	O
would	O
be	O
a	O
jquery	B-Fram
plugin	O
that	O
can	O
do	O
the	O
work	O
-	O
something	O
like	O
CharLimit	B-API
,	O
but	O
it	O
should	O
be	O
able	O
to	O
limit	O
text	O
line	O
count	O
not	O
character	O
count	O
.	O

Thanks	O
in	O
advance	O
.	O

The	O
number	O
of	O
visible	O
/	O
display	O
lines	O
for	O
a	O
given	O
block	O
of	O
text	O
would	O
vary	O
with	O
different	O
browsers	O
,	O
fonts	O
used	O
,	O
etc	O
.	O

You'd	O
have	O
to	O
set	O
a	O
specific	O
font	O
and	O
font-size	O
,	O
at	O
a	O
minimum	O
,	O
to	O
be	O
able	O
to	O
semi-reliably	O
count	O
display	O
lines	O
.	O

UPDATE	O
:	O
I	O
see	O
the	O
edit	O
.	O

Then	O
something	O
like	O
kevchadders	O
code	O
should	O
do	O
fine	O
for	O
you	O
.	O

You'll	O
need	O
js	O
that	O
counts	O
chars	O
and	O
'	O
\r\n	O
'	O
s	O
and	O
checks	O
against	O
a	O
user-defined	O
limit	O
.	O

Also	O
,	O
if	O
you	O
don't	O
use	O
his	O
script	O
,	O
make	O
sure	O
you	O
use	O
one	O
that	O
involves	O
either	O
a	O
time	O
interval	O
check	O
and	O
/	O
or	O
the	O
onKeyDown	O
/	O
onKeyUp	O
events	O
of	O
the	O
textarea	O
.	O

This	O
may	O
be	O
why	O
some	O
scripts	O
you	O
have	O
tested	O
seem	O
to	O
"	O
behave	O
strangely	O
"	O
.	O

did	O
you	O
try	O
the	O
rows	O
attribute	O
?	O

This	O
might	O
help	O
(	O
probably	O
be	O
best	O
using	O
jQuery	B-Fram
,	O
onDomReady	O
and	O
unobtrusively	O
adding	O
the	O
keydown	O
event	O
to	O
the	O
textarea	O
)	O
but	O
tested	O
in	O
IE7	O
and	O
FF3	O
:	O

*	O
Edit	O
-	O
explanation	O
:	O
It	O
catches	O
the	O
keypress	O
if	O
the	O
ENTER	O
key	O
is	O
pressed	O
and	O
just	O
doesn't	O
add	O
a	O
new	O
line	O
if	O
the	O
lines	O
in	O
the	O
textarea	O
are	O
the	O
same	O
number	O
as	O
the	O
rows	O
of	O
the	O
textarea	O
.	O

Else	O
it	O
increments	O
the	O
number	O
of	O
lines	O
.	O

This	O
is	O
basically	O
the	O
same	O
as	O
Ivan	O
'	O
s	O
answer	O
,	O
using	O
jQuery	B-Fram
.	O

I	O
tested	O
it	O
for	O
a	O
project	O
of	O
my	O
own	O
;	O
seems	O
to	O
work	O
fine	O
.	O

How	O
to	O
do	O
it	O
with	O
jQuery	B-Fram
:	O

Bind	O
to	O
keyDown	O
event	O
of	O
textarea	O
.	O

(	O
Done	O
with	O
jquery	B-Fram
)	O
.	O

It	O
'	O
s	O
not	O
perfect	O
but	O
cares	O
about	O
wrapping	O
.	O

Not	O
deppending	O
only	O
of	O
the	O
end	O
of	O
line	O
(	O
\n	O
)	O
.	O
jquery	B-Fram
scroll	O
event	O
have	O
problems	O
in	O
mozilla	O
and	O
firefox	B-MISC
if	O
css	B-PL
overflow	O
property	O
in	O
textarea	O
is	O
not	O
auto	O
,	O
otherwise	O
remove	O
the	O
corresponding	O
lines	O
and	O
set	O
overflow	O
hidden	O
.	O

Could	O
help	O
the	O
css	B-PL
resize	O
:	O
none	O
and	O
fixed	O
height	O
.	O

I	O
extended	O
it	O
a	O
bit	O
to	O
detect	O
even	O
overflow	O
without	O
a	O
manual	O
linebreak	O
.	O

This	O
is	O
for	O
fixed	O
size	O
textarea	O
with	O
"	O
overflow	O
:	O
hidden	O
"	O
.	O

At	O
the	O
moment	O
my	O
solution	O
makes	O
the	O
font	O
smaller	O
if	O
it	O
doesn't	O
fit	O
to	O
textarea	O
.	O

And	O
makes	O
it	O
larger	O
again	O
if	O
possible	O
.	O

var	O
keynum	O
,	O
allowedLines	O
=	O
5	O
,	O
defaultFontSize	O
=	O
13	O
/	O
*px*	O
/;	O

$	O
(	O
document	O
)	O
.ready	O
(	O
function()	B-API
{	O

$	O
(	O
"	O
textarea	O
")	O
.keydown	O
(	O
function	O
(	O
e	O
,	O
obj	O
)	O
{	O

if	O
(	O
window.event	B-API
)	O

keynum	O
=	O
e.keyCode	B-API
;	O

else	O
if	O
(	O
e.which	B-API
)	O

keynum	O
=	O
e.which	B-API
;	O

if	O
(	O
keynum	O
==	O
13	O
allowedLines	O
=	O
$	O
(	O
this	O
)	O
.val	O
(	O
)	O
.split	O
(	O
"	O
\n	O
")	O
.length	O
)	O

return	O
false	O
;	O

}	O
);	O

$	O
(	O
"	O
textarea	O
")	O
.keyup	O
(	O
function	O
(	O
e	O
,	O
obj	O
)	O
{	O

//	O
Avoid	O
copy-paste	O

if	O
(	O
allowedLines	O
$	O
(	O
this	O
)	O
.val	O
(	O
)	O
.split	O
(	O
"	O
\n	O
")	O
.length	O
)	O
{	O

lines	O
=	O
$	O
(	O
this	O
)	O
.val	O
(	O
)	O
.split	O
(	O
"	O
\n	O
")	O
.slice	O
(	O
0	O
,	O
allowedLines	O
);	O

$	O
(	O
this	O
)	O
.val	O
(	O
lines.join	B-API
(	O
'	O
\n	O
')	O
);	O

}	O

//	O
Check	O
overflow	O

if	O
((	O
this.clientHeight	B-API
this.scrollHeight	B-API
))	O
{	O

while	O
((	O
this.clientHeight	B-API
this.scrollHeight	B-API
))	O
{	O

currFontSize	O
=	O
$(this).css('font	O
-size	O
')	O
;	O

finalNum	O
=	O
parseFloat	O
(	O
currFontSize	O
,	O
11	O
);	O

stringEnding	O
=	O
currFontSize.slice	B-API
(	O
-2	O
);	O

$(this).css('font	O
-size	O
'	O
,	O
(	O
finalNum-1	O
)	O
+	O
stringEnding	O
);	O

}	O

}	O
else	O
if	O
($(this).css('fontSize	O
')	O
!	O
=	O
defaultFontSize+'px	O
')	O
{	O

while	O
($(this).css('font	O
-size	O
')	O
!	O
=	O
defaultFontSize+'px	O
')	O
{	O

//	O
First	O
lets	O
increase	O
the	O
font	O
size	O

currFontSize	O
=	O
$(this).css('font	O
-size	O
')	O
;	O

finalNum	O
=	O
parseFloat	O
(	O
currFontSize	O
,	O
11	O
);	O

stringEnding	O
=	O
currFontSize.slice	B-API
(	O
-2	O
);	O

$(this).css('font	O
-size	O
'	O
,	O
(	O
finalNum+1	O
)	O
+	O
stringEnding	O
);	O

//	O
lets	O
loop	O
until	O
its	O
enough	O
or	O
it	O
gets	O
overflow	O
again	O

if	O
(	O
this.clientHeight	B-API
this.scrollHeight	B-API
)	O
{	O

//	O
there	O
was	O
an	O
overflow	O
and	O
we	O
have	O
to	O
recover	O
the	O
value	O

$(this).css('font	O
-size	O
'	O
,	O
currFontSize	O
);	O

break	O
;	O

}	O

}	O

}	O

}	O
);	O

}	O
);	O

This	O
solution	O
works	O
:	O

and	O
text	O
area	O
would	O
be	O

in	O
regular	O
HTML	B-PL
:	O

jQuery	B-Fram
example	O
.	O

This	O
works	O
for	O
both	O
typing	O
and	O
pasting	O
.	O
